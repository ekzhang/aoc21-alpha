# Learnings

I learned quite a bit by solving these puzzles in 25 different programming languages. Here are some notes I took along the way: observations about strengths, weaknesses, surprising moments, and different programming paradigms.

- Zig is quite low-level and makes you think hard about memory allocation (some learning curve), but it seems to provide good abstractions.
- Having good searchable documentation for your programming language makes using it a lot easier.
- WebAssembly has richer control flow but is super verbose / painful to write by hand.
- V seems to do lots of nice things but is still kind of janky / unstable as a language.
- You shouldn't write actual program logic in shell scripts, it's slow and really painful to debug, e.g., getting killed by the difference between `(( ... ))` and `[[ ... ]]`. Shell scripts also have an extremely impoverished syntax for abstractions & returning from functions.
- Scala is actually really nice, despite the negative press! I'm surprised, they have syntax shortcuts for everything and an enjoyable functional programming experience.
- Ruby is not quite as nice as I remember, no first-class functions feels a bit weird. Compiler error messages were confusing.
- I've felt myself doing a lot of "compiler-driven development" when the docs are not clear, i.e., just changing something, rerunning it, and seeing if it works.
- REPLs are also very good for exploring new languages quickly (Scala, V, Ruby) and testing out small parts of the program, due to the tight feedback loop. However, if the language was sufficiently fast (rerunning takes <200 ms) and had good error messages, I didn't find having a REPL necessary.
- For specialized languages like Q# and KDB+'s Q query grammar, it's very difficult to use them for standard programming tasks, since it's not their focus.
- Running SQL outside of a database environment is difficult, and even specialized tools like Q don't have full support for things like CTEs and selecting from nested subqueries, unfortunately. This could be fixed in the future by a better tool though.
- Writing code in Prolog felt very strange. On one hand, it was **extremely** declarative, and I've never seen a parentheses-matching style problem be solved in a way that completely decouples the pairs as data, separate from the rest of the code. On the other hand, I don't fully understand the semantics of the language and therefore have no idea what the time complexity of my code is.
- I've noticed this before, but OCaml is not very good at tasks that don't fit the standard functional "ML" paradigm. Working with references, arrays, and loops is very awkward.
- Nim's flexible procedure calling syntax is extremely interesting. I realized halfway into my program that I could rewrite `readLine(stdin)` as `stdin.readLine` or `readLine stdin`, and I could rewrite `incl(vis, cave)` as `vis.incl(cave)`. It's also neat that this is all static dispatch.
- MoonScript really just **feels nice**. I think Lua has a lot of limitations, particularly around its table data structure (or really, lack of other data structures), but it's still fairly simple and enjoyable to work with. Also, MoonScript makes the syntax quite a lot nicer, even for a beginner like myself.
- In languages with more flexible calling syntax, like MoonScript, Nim, and Ruby, I barely used any parentheses at all. It's not that important semantically, but it feels much nicer to type because your hand can stay near the center of your keyboard.
- I spent 30 minutes figuring out that `(mapcan)` is the equivalent of flatMap in Common Lisp, an hour or so messing around with the `(loop)` macro, 15 minutes trying to figure out how to concatenate characters into a string, et cetera. That pretty much sums it up: huge language with plenty of historical baggage, poor error messages, and sparse documentation.
- That said, Common Lisp will always hold a special place in my heart as my first introduction to functional programming and the beautiful homoiconicity of Lisps. It's just unfortunate that the language is so janky in modern terms.
- Having a powerful macro system in your language is a double-edged sword (and Lisp is the strongest example of this), since it undermines the ability to do static analysis and build programmer tools like auto-completion, LSPs, formatting (how the heck do you indent `(let)` and `(do)` naturally?).
- Kotlin is a good all-around language for small programming problems, though I think it has a few warts, particularly around the collections classes that I was using. Doesn't seem as **nice** as Scala.
- With some practice I could see myself being very fast at competitive programming in Kotlin, which isn't something I could say about many languages on this list.
- Despite being targeted at numeric computing, Julia still excels as a general-purpose language.
- Idris was extremely interesting to learn and also enjoyable to use, for such a small language. I didn't directly use the dependent typing features or holes, but the built-in parser combinator library `Data.String.Parser` was easy to use for input parsing, the language tooling was great, and the documentation was fairly concise and clear. The code kind of just fell into place for me.
- Haskell is pretty enjoyable to use in VS Code, with the current language server (including import management and holes!) and automatic formatter. Cabal also seems very concise. I can see Rust's best influences from Haskell: derive, Cargo, and traits being some of them.
- I don't fully understand the operational semantics and guarantees of lazy evaluation in Haskell, primarily around IO-related functions like `getContents`. What happens when you apply `lines` to the result of this; is the resulting list lazily evaluated?
- Regardless, lazy evaluation is a nice application of Haskell's declarative, functional nature and is easy to understand cognitively, at least in terms of denotational semantics.
- I was pretty lucky to be doing Day 19 in Go, since this problem was easily accelerated with a bit of parallelism. On my machine, adding just a couple lines of code to make a channel and spawn goroutines in my graph algorithm made the code run ~5x faster, taking it from 10 seconds to 2 seconds.
- I like languages like F# that are functional (in this case, mimicking OCaml) but also are very pragmatic about having object-oriented and procedural features that don't suck. Sometimes this is the cleanest way to write something.
- Although F# is not the fastest language out there, I was able to speed up my code by a couple multiples by just changing one character: from `Seq.filter` to `PSeq.filter`. Now, the bottleneck in execution time for this problem is actually just the compiler.
- Elixir's actor model is powerful and interesting, although it's somewhat specialized to the task of building concurrent functional systems. The language syntax itself seemed a little awkward compared to F# and Haskell, for algorithmic problems. However, I think the language server and auto-formatter made working with Elixir much easier, and the language feels very modern.
- Some design choices in Elixir, like having all functions be in modules and requiring strict immutability, seem strange at first. However, they make sense in the context of hot reloading and concurrency.
- Unfortunately, Dart didn't deliver too well on language features. The syntax also is awkward in places. At least the developer tools are good, and since it's meant for user interfaces rather than primarily for systems, I guess this is fine.
- The functional features that Dart has are nice, but they feel somewhat incomplete. Still, I enjoyed having static type checking with a fast JIT compiler, and the language is pragmatic.
- Solving algorithmic problems with a language can give you a good cross-sectional slice of its features, but you need to try intentionally to really learn the way of thinking in the language. This is typically measured in metrics like conciseness, expressivity, or elegance.
- Crystal is a really nice language that feels pretty good ergonomically. Their web-based playground environment is a good learnable programming tool.
- In addition to being orders of magnitude faster than Ruby, I liked how Crystal's type-checking was pragmatic to help catch my errors and accidental mistypings. The standard library APIs are full and well-designed to handle many use cases (like Rust's std!), it's easy to specify protocols like hash functions, and there are convenient stack-memory types like `StaticArray(T, N)`.
- I have no idea how Boolector works, but I'm glad that it existed for Day 24's exercise. Dynamically generating an SMT solver's IR to write a simple symbolic executor was pretty fun. Still, I think Z3 is much easier to install and use.
- AssemblyScript is quite neat, though the nature of JavaScript being so dynamic creates a bit of mismatch between the language and its static WebAssembly target.
